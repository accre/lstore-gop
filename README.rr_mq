The overall architecture of the round robin system is as follows:

----------         ----------         ----------
| Client | ------> | Server | ------> | Worker |
----------         ----------    |    ----------
                                 |    ----------
                                 |--> | Worker |
                                 |    ----------
                                ...
                                 |    ----------
                                 |--> | Worker |
                                      ----------

---------------------------------------------------------------------
RR_MQ_CLIENT
---------------------------------------------------------------------

The client is largely the same as any other client. As far as the
client is concerned, it is sending messages to the server, and the
server is processing and responding to them.

---------------------------------------------------------------------
RR_MQ_SERVER
---------------------------------------------------------------------

The server sits in between the client and workers and passes messages
appropriately.

There are two main data structures the server uses:
 - mq_worker_t
 - mq_worker_table_t
 - processing_queue
The mq_worker_t struct just contains the worker's address and number
of free slots. The number of free slots is an artificial limitation
on the server. It is entirely possible to continue sending messages
if free_slots = 0 if you delete the checks.

The mq_worker_table_t and processing_queue structures are based on
Stack_t. Helper functions for them are in rr_mq_roundrobin.c/h. Both
of these also use mutexes to control access, because workers/messages
are popped and pushed on and off of them by multiple threads.

The server reacts to only 3 commands:
 - REGISTER
 - DEREGISTER
 - INCREMENT
All three are used for worker control/manipulation.

REGISTER:
This message is sent by a worker to the server. The message contains
a frame with the number of free slots this worker will have.
Currently, all workers have 10 slots. The final frame of this message
contains the worker's unique portal address.

The server stores both parameters in an mq_worker_t object, which is
then added to the worker table. If a worker at that address already
exists, the number of free slots is overwritten to this new value.

DEREGISTER:
The opposite of REGISTER. The server searches for the unique address
(last frame of message) and removes that mq_worker_t object if it
exists. If it doesn't exist, it is ignored.

INCREMENT:
This is sent by the worker upon completing a task (doesn't matter if
the task failed or was successful).

The server again takes the unique address, finds the mq_worker_t in
the table with that address, and increments its number of free slots.

Worker Table:
The worker table behaves as a "least-recently-used" queue. When an
incoming message needs to be passed to a worker, the first worker in
the table is popped. If that worker has at least 1 free slot:
 1. The message is passed to it
 2. Its number of free slots is decremented
 3. It gets added back to the worker table at the bottom
If the worker has no free slots, it is simply added to the bottom
of the table.

The server will continue to try popping the top worker until it finds
a worker with at least 1 free slot. If it checks all workers and does
not find an available one, the message is added to the processing
queue.

The function display_worker_table() will list all registered workers,
their address, and their free slots.

Processing Queue:
The processing queue is used to store messages when all workers are
at capacity. The processing queue does not have a limit to how many
messages it can store. The processing queue is used in two places.

The first is in process_round_robin_pass as described above. If all
workers are busy, the incoming message is added to the processing
queue. Additionally, process_round_robin_pass checks to see if the
processing queue already has messages in it.

Messages already in the queue take priority because they have been
waiting. The current message is added to the bottom of the processing
queue and the server attempts to send as many of the existing items
as possible.

The other place the queue is used is in the queue_checker thread.
This is a background thread that periodically (currently every 1
second) checks the processing queue for backlogged messages. If any
exist, the server attempts to send as many as possible in exactly
the same way as process_round_robin_pass.

process_round_robin_pass():
This function does most of the work in the server. It is the default
function for messages that are not one of the three listed above.

Upon receiving a message the server will check if there is still an
address frame on top.

If there is, the server uses mq_submit() to send the message.
Additionally, a new parameter in mq_task_t, pass_through, gets set.
This lets the task go without being added to the heartbeat table,
since the server does not need a response.

If there is not, this message needs to be passed to a worker. The
mq_worker_table_t section above describes what happens.

---------------------------------------------------------------------
RR_MQ_WORKER
---------------------------------------------------------------------

Workers largely behave like servers do in a regular MQ setup. That
is, they receive messages, process them, and respond if necessary.

Workers need to send a REGISTER message to the server in order to
receive anything. This message should contain the number of free
slots this worker is willing to have. A REGISTER message requires a
response from the server. If it is successful, the worker will then
install commands on its newly created client portal. The ongoing is
also created here.

When a worker is shutting down, it needs to send a DEREGISTER message
to the server so it can be removed from the server's table. This is a
fire-and-forget message.
